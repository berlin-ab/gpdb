-- CREATE TABLESPACE

create or replace language plpythonu;


create or replace function remove_tablespace_directory(tablespace_dir text) returns void as $$
	import shutil;
	import os;
	import subprocess
	import os
	import glob
	working_directory = os.getcwd()
	tablespace_directory  = working_directory + "/pg_tblspc"
	result = glob.glob("{tablespace_directory}".format(tablespace_directory=tablespace_directory))

	full_list = [ 
		[found_tablespace_dir + '/' + tablespace_oid 
			for tablespace_oid in os.listdir(found_tablespace_dir)
			] for found_tablespace_dir 
				in result
				if found_tablespace_dir 
	]
	
	tablespace_links_to_remove = [
		found_tablespace_directory 
			for found_tablespace_directory 
			in sum(full_list, []) 
			if os.readlink(found_tablespace_directory).startswith(tablespace_dir) ]
	
	for tablespace_link_to_remove in tablespace_links_to_remove:
		os.unlink(tablespace_link_to_remove);

	try:
		shutil.rmtree(tablespace_dir);
	except OSError:
		pass
$$ LANGUAGE plpythonu;


create or replace function setup_tablespaces_for_test(tablespace_dir text) returns void as $$
	import os;
	os.mkdir(tablespace_dir);
$$ LANGUAGE plpythonu;


create or replace function setup(content_id integer, fault_name text, fault_action_type text, tablespace_dir text) returns void as $$
	begin
		-- reset tablespace directories
		perform remove_tablespace_directory(tablespace_dir);
		perform remove_tablespace_directory(tablespace_dir) from gp_dist_random('gp_id');
		perform setup_tablespaces_for_test(tablespace_dir);

		-- setup faults
		perform gp_inject_fault2('all', 'reset', dbid, hostname, port) from gp_segment_configuration where content = content_id and role = 'p';
		perform gp_inject_fault2(fault_name, fault_action_type, dbid, hostname, port) from gp_segment_configuration where content = content_id and role = 'p';
	end;
$$ LANGUAGE plpgsql;


create or replace function cleanup(content_id integer, tablespace_dir text) returns void as $$
	begin
		perform gp_inject_fault2('all', 'reset', dbid, hostname, port) from gp_segment_configuration where content = content_id and role = 'p';
		perform remove_tablespace_directory(tablespace_dir);
		checkpoint;
	end;
$$ LANGUAGE plpgsql;


create or replace function list_tablespaces(expected_number_of_tablespaces integer, tablespace_directory text) returns varchar[] as $$
	import glob
	rows = glob.glob("{tablespace_directory}/*".format(tablespace_directory=tablespace_directory))
	rows.sort()

	found_number_of_tablespaces = len(rows)
	was_success = expected_number_of_tablespaces == found_number_of_tablespaces

	result = []

	if was_success:
		result.append("Success")
	else:
		result.append("Failed")

	result.append('expected {expected_number_of_tablespaces} tablespaces'.format(expected_number_of_tablespaces=expected_number_of_tablespaces))
	result.append('found %d tablespaces' % found_number_of_tablespaces)
	for row in rows:
		result.append(str(row))
	return result
$$ language plpythonu;


create or replace function give_mirrors_time_to_catch_up() returns void as $$
declare number_of_segments_behind integer;
declare number_of_retries integer default 0;
begin
	CHECKPOINT;
	LOOP
		IF number_of_retries = 50 THEN
			raise EXCEPTION 'too many retries waiting for mirrors to catch up';
		END IF;

		select count(1) into number_of_segments_behind from (select gp_execution_segment(), pg_last_xlog_replay_location() as replayed, pg_last_xlog_receive_location() as recieved UNION ALL select gp_execution_segment(), pg_last_xlog_replay_location() as replayed, pg_last_xlog_receive_location() as recieved from gp_dist_random('gp_id')) thing where replayed != recieved;
		number_of_retries := number_of_retries + 1;

		EXIT WHEN number_of_segments_behind = 0;

		perform pg_sleep(0.1);
	END LOOP;
end;
$$ language plpgsql;


create or replace function list_tablespace_catalog() returns table(gp_segment_id int, tablespace_name text, oid oid) as $$
	select -1 as gp_segment_id, spcname::text, oid from pg_tablespace
	UNION ALL
	select gp_segment_id, spcname::text, oid from gp_dist_random('pg_tablespace')
	order by gp_segment_id, spcname
$$ language sql;


create or replace function list_tablespace_catalog_without_oid() returns table(gp_segment_id int, tablespace_name text) as $$
	select -1 as gp_segment_id, spcname::text from pg_tablespace
	UNION ALL
	select gp_segment_id, spcname::text from gp_dist_random('pg_tablespace')
	order by gp_segment_id, spcname
$$ language sql;


--
-- An error after XLOG_TBLSPC_CREATE on master
--
-- expected: tablespace should not exist after abort
--
\set content_id_under_test -1
\set expected_number_of_tablespaces 0
\set error_type error
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set after_xlog_create_tablespace

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


--
-- An error after XLOG_TBLSPC_CREATE on primary
--
-- expected: tablespace should not exist after abort
--
\set content_id_under_test 0
\set expected_number_of_tablespaces 0
\set error_type error
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set after_xlog_create_tablespace

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


--
-- An panic after XLOG_XACT_PREPARE on primary
--
-- expected: tablespace should not exist after abort
--
\set content_id_under_test 0
\set expected_number_of_tablespaces 0
\set error_type panic
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set after_xlog_xact_prepare_flushed

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


--
-- An error before XLOG_XACT_PREPARE on primary
--
\set content_id_under_test 0
\set expected_number_of_tablespaces 0
\set error_type error
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set before_xlog_xact_prepare

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');

--
-- An error after XLOG_XACT_PREPARE on primary
--
-- This leaves a dangling global transaction in the proc array,
-- but should not happen in practice.
--

--
-- An panic before XLOG_XACT_PREPARE on primary
--
-- expected: tablespaces should be cleaned up everywhere
--           except where the panic happened.
--
-- context:  we no longer have any history of the transaction taking place.
--           it is no longer in memory, and we did not succeed in writing the
--           prepared transaction, therefore we cannot safely clean
--           the tablespace directory.
--
\set content_id_under_test 0
\set expected_number_of_tablespaces 1
\set error_type panic
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set before_xlog_xact_prepare

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


--
-- An unrelated aborted transaction after a `CREATE TABLESPACE`
--    should not effect the created tablespaces.
--
-- expected: tablespace directories should still exist
--
\set tablespace_location /tmp/my_tablespace_for_testing
\set expected_number_of_tablespaces 8
\set content_id_under_test -1

select remove_tablespace_directory(:'tablespace_location');
select setup_tablespaces_for_test(:'tablespace_location');
create tablespace my_tablespace_for_testing LOCATION :'tablespace_location';
select * from give_mirrors_time_to_catch_up();

-- force an aborted transaction which should no longer see a
--     pending tablespace for deletion
begin;
abort;

-- the tablespace should exist in the catalog
select * from list_tablespace_catalog_without_oid();

-- the tablespace should exist on disk
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


--
-- An error before XLOG_XACT_DISTRIBUTED_COMMIT on master
--
-- expected: tablespaces should be cleaned up everywhere
--
--
\set content_id_under_test -1
\set expected_number_of_tablespaces 0
\set error_type error
\set tablespace_location /tmp/my_tablespace_for_testing
\set fault_to_set before_xlog_xact_distributed_commit

select setup(:content_id_under_test, :'fault_to_set', :'error_type', :'tablespace_location');
CREATE TABLESPACE my_tablespace_for_testing LOCATION :'tablespace_location';
select give_mirrors_time_to_catch_up();
select * from list_tablespace_catalog();
select list_tablespaces(:expected_number_of_tablespaces, :'tablespace_location');
DROP TABLESPACE my_tablespace_for_testing;
select cleanup(:content_id_under_test, :'tablespace_location');


-- XLOG_TBLSPC_CREATE (on master)

-- ? - then tablespace should not exist VIA ABORT

-- XLOG_TBLSPC_CREATE (on primary)

-- ? - then tablespace should not exist VIA ABORT 
 
-- XLOG_XACT_PREPARE (on primary)

-- ? - then tablespace should not exist VIA ABORT 

-- XLOG_XACT_DISTRIBUTED_COMMIT (on master)

-- ? - then tablespace should exist on disk
 
-- XLOG_XACT_COMMIT_PREPARED (on primary)

-- ? - then tablespace should exist on disk

-- XLOG_XACT_DISTRIBUTED_FORGET (on master) 

-- ? - then tablespace should exist on disk

-- When the dtx[Command] fails